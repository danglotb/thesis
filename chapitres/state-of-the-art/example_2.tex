\subsection{Example}
\label{subsec:sota:category-2:example}

\autoref{lst:example:ampchange:original} shows a toy class and two test cases designed to verify its code.
At some point in development, the code of the method is modified as shown in \autoref{lst:example:ampchange:modified}. 
The change consists of the addition of a new block in line \ref{line:example:ampchange:modified}. 

\begin{lstlisting}[caption={Initial version of a class and two test cases},label=lst:example:ampchange:original,float,language=java,numbers=left]
class Computer{
	public int computeValue(int input) {
		if(input < 3) {
			return input/2;
		}
		return 0;
	}
}

class ComputerTest {
	int threshold = 4;

	@Test
	public testSmallInput() {
		Computer comp = new Computer();
		assertTrue(comp.computeValue(2) < threshold);
	}

	@Test
	public testDefault() {
		Computer comp = new Computer();
		assertEquals(comp.computeValue(10), 0);
	}
}
\end{lstlisting}

\begin{lstlisting}[caption={Modified version of the initial class},label=lst:example:ampchange:modified,float,language=java,numbers=left]
class Computer{
	public int computeValue(int input) {
		if(input < 3) {
			return input/2;
		}
		if (input <= 5) { (*@ \label{line:example:ampchange:modified} @*)
			return 2*input;
		}
		return 0;
	}
}
\end{lstlisting}

The existing test cases do not execute the new code.
There is no test input in the $[3,5]$ interval. 
An $AMP_{change}$ technique would increment the test suite with a new test case, like the one shown in \autoref{lst:example:ampchange:amplified}, that covers the new code. 
The technique should be able to generate an input that meets the requirement to reach the new or changed code and the right oracle given the new conditions. 

\begin{lstlisting}[caption={A test case that covers the new portion of  code.},label=lst:example:ampchange:amplified,float,language=java,numbers=left]
@Test
public testInput() {
	Computer comp = new Computer();
	assertTrue(comp.computeValue(4) > threshold);
}
\end{lstlisting}
